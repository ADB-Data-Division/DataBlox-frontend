---
- name: Deploy Datablox App
  hosts: azure_vm
  become: yes
  vars:
      app_image: "ghcr.io/darrensapalo/capacity-building-visualization:latest"
      app_name: "capacity-building-viz"
      app_port: "3000"
      # domain is now set in inventory.ini

      # Computed environment variables dictionary (uses values from inventory.ini with defaults)
      app_env_vars:
          PORT: "3000"
          NEXT_PUBLIC_URL: "{{ app_url | default('https://' + domain) }}"
          NEXT_PUBLIC_BACKEND_URL: "{{ backend_url | default('https://' + domain + '/api/v1') }}"
          NEXT_PUBLIC_GRAPHQL_URL: "{{ graphql_url | default('https://hasura.' + domain + '/v1/graphql') }}"
          NEXT_PUBLIC_AUTH0_DOMAIN: "{{ auth0_domain | default('auth.' + domain) }}"
          NEXT_PUBLIC_AUTH0_CLIENT_ID: "{{ auth0_client_id | default('your-auth0-client-id') }}"
          NEXT_PUBLIC_AUTH0_REDIRECT_URI: "{{ auth0_redirect_uri | default('https://' + domain + '/api/auth/callback') }}"
          NEXT_PUBLIC_AUTH0_AUDIENCE: "{{ auth0_audience | default('https://hasura.' + domain + '/v1/graphql') }}"
          NEXT_PUBLIC_GA_MEASUREMENT_ID: "{{ ga_measurement_id | default('G-XXXXXXXXXX') }}"
          NEXT_PUBLIC_AMPLITUDE_API_KEY: "{{ amplitude_api_key | default('your-amplitude-key') }}"
          # NextAuth.js specific environment variables
          AUTH0_CLIENT_ID: "{{ auth0_client_id | default('your-auth0-client-id') }}"
          AUTH0_CLIENT_SECRET: "{{ auth0_client_secret | default('your-auth0-client-secret') }}"
          AUTH0_ISSUER: "{{ auth0_issuer | default('https://' + (auth0_domain | default('auth.' + domain))) }}"
          AUTH_SECRET: "{{ auth_secret | default('your-auth-secret-key-here') }}"

  tasks:
      - name: Pull latest application image
        shell: docker pull {{ app_image }}
        become_user: "{{ ansible_user }}"
        register: pull_result

      - name: Display pull result
        debug:
            msg: "Image pull {{ 'successful' if pull_result.rc == 0 else 'failed' }}"

      - name: Stop existing container if running
        shell: docker stop {{ app_name }}
        ignore_errors: yes
        become_user: "{{ ansible_user }}"

      - name: Remove existing container
        shell: docker rm {{ app_name }}
        ignore_errors: yes
        become_user: "{{ ansible_user }}"

      - name: Check if traefik network exists
        shell: docker network ls | grep traefik
        register: traefik_network_check
        ignore_errors: yes
        become_user: "{{ ansible_user }}"

      - name: Create traefik network if it doesn't exist
        shell: docker network create traefik
        when: traefik_network_check.rc != 0
        become_user: "{{ ansible_user }}"

      - name: Display environment variables that will be used
        debug:
            msg: "Environment variables: {{ app_env_vars }}"

      - name: Run new container with Traefik labels
        shell: |
            docker run -d \
              --name {{ app_name }} \
              --network traefik \
              --restart unless-stopped \
              -p {{ app_port }}:3000 \
              {% for key, value in app_env_vars.items() %}
              -e "{{ key }}={{ value }}" \
              {% endfor %}
              -l "traefik.enable=true" \
              -l "traefik.http.routers.{{ app_name }}.rule=Host(\`{{ domain }}\`)" \
              -l "traefik.http.routers.{{ app_name }}.entrypoints=web" \
              -l "traefik.http.routers.{{ app_name }}-secure.rule=Host(\`{{ domain }}\`)" \
              -l "traefik.http.routers.{{ app_name }}-secure.entrypoints=websecure" \
              -l "traefik.http.routers.{{ app_name }}-secure.tls=true" \
              -l "traefik.http.routers.{{ app_name }}-secure.tls.certresolver=letsencrypt" \
              -l "traefik.http.middlewares.{{ app_name }}-redirect.redirectscheme.scheme=https" \
              -l "traefik.http.middlewares.{{ app_name }}-redirect.redirectscheme.permanent=true" \
              -l "traefik.http.routers.{{ app_name }}.middlewares={{ app_name }}-redirect" \
              -l "traefik.http.services.{{ app_name }}.loadbalancer.server.port=3000" \
              {{ app_image }}
        become_user: "{{ ansible_user }}"
        register: container_run

      - name: Display container run result
        debug:
            msg: "Container {{ 'started successfully' if container_run.rc == 0 else 'failed to start' }}"

      - name: Wait for container to be healthy
        pause:
            seconds: 15

      - name: Check container status
        shell: docker ps --filter "name={{ app_name }}"
        become_user: "{{ ansible_user }}"
        register: container_status

      - name: Display container status
        debug:
            var: container_status.stdout_lines

      - name: Wait for application to be ready
        uri:
            url: "http://localhost:{{ app_port }}"
            method: GET
            timeout: 30
            status_code: [200, 302, 404] # Accept various status codes during startup
        register: health_check
        retries: 5
        delay: 10
        until: health_check.status is defined

      - name: Display health check result
        debug:
            msg: "Application is {{ 'accessible' if health_check.status is defined else 'not accessible' }} on localhost:{{ app_port }}"

      - name: Verify environment variables are set in container
        shell: docker exec {{ app_name }} printenv | grep NEXT_PUBLIC_
        become_user: "{{ ansible_user }}"
        register: container_env_vars
        ignore_errors: yes

      - name: Display container environment variables
        debug:
            var: container_env_vars.stdout_lines

      - name: Check container logs for any errors
        shell: docker logs --tail 20 {{ app_name }}
        become_user: "{{ ansible_user }}"
        register: container_logs
        ignore_errors: yes

      - name: Display recent container logs
        debug:
            var: container_logs.stdout_lines

      - name: Display access instructions
        debug:
            msg: |
                Deployment complete! 

                Local access: http://localhost:{{ app_port }}
                External access: http://{{ domain }}:{{ app_port }}

                Via Traefik with SSL: https://{{ domain }}
                Via Traefik HTTP (redirects to HTTPS): http://{{ domain }}

                To check logs: docker logs {{ app_name }}
                To check status: docker ps --filter "name={{ app_name }}"
                To check Traefik logs: docker logs traefik
